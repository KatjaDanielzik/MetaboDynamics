---
title: "filling_package_skeleton_with_life"
author: "Katja Danielzik"
date: "2024-08-07"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# setup package documentation
```{r}
use_package_doc()
document()
```


# dependencies
```{r}
use_package("stringr", "imports",min_version=TRUE) # min_version=TRUE sets to current version
use_package("rstan","imports",min_version = TRUE)
use_package("ggplot2","imports",min_version=TRUE)
use_package("dplyr","imports",min_version=TRUE)
use_package("tidyr","imports",min_version = TRUE)
```


# raw data 
will be worked on later

# data
## KEGG-database 
these files are summaries of the pull request from KEGG via KEGGREST
```{r}
# total background information
modules_compounds  <- readr::read_csv("/media/home/5.1-package-pipeline/modules_compounds.csv")
#correct spelling error
colnames(modules_compounds) <- gsub("hierachy","hierarchy",colnames(modules_compounds))
usethis::use_data(modules_compounds,overwrite=TRUE)
promptData(modules_compounds)

# experimental metabolites mapped to modules
metabolite_modules <- readr::read_csv("/media/home/5.1-package-pipeline/metabolite_modules.csv")
colnames(metabolite_modules) <- gsub("hierachy","hierarchy",colnames(metabolite_modules))
usethis::use_data(metabolite_modules,overwrite=TRUE)
promptData(metabolite_modules)

# suggest KEGGREST as package for developers to test the code or obtain own datasets
devtools::use_package("KEGGREST","suggests",min_version=TRUE)
devtools::document()
```
import already pre-processed intracellular metabolite concentrations with one
column specifying the experimental condition (in our case radiation dose) and
one column specifying time (numerical)

## simulated data
I am simulating at dataset with up to 98 metabolites (=experimental metabolites)
with 3 experimental conditions and 8 dynamic groups each. 4 of which are varying
between conditions. Each metabolite has individual varying variances of 3 
measurement replicates between 4 timepoints coming. 
```{r}
# load KEGG database for assignment of metabolite names:
data("metabolite_modules")

# metabolite_db <- metabolite_modules
# Group <- middle_hierarchy

library(dplyr)
# Parameters (as before)
n_features <- 98 #sample(1:length(unique(metabolite_modules$metabolite)),1) # Number of features (max=98 for current mapping of metabolite to database)
n_groups <- 8 # Number of groups (randomly choose between 6-8)
n_time_points <- 4 # Number of time points
n_replicates <- 3 # Number of replicates for all features and time points
n_conditions <- 3 # Number of experimental conditions
x_varying_groups <- 4 # Number of groups with varying dynamics across conditions
condition_names <- c("A","B","C")

# Probability matrix for assigning metabolites from different database groups to dynamic groups
# For simplicity, we assume equal probability; customize as needed
group_probabilities <- matrix(runif(n_groups * length(unique(metabolite_modules$middle_hierarchy))),
                              nrow = n_groups,
                              ncol = length(unique(metabolite_modules$middle_hierarchy)))

# Generate group dynamics (base trends over time) for each condition
group_dynamics <- list()

# Define the base group dynamics for condition 1
group_dynamics[[1]] <- lapply(1:n_groups, function(g) {
  trend <- rnorm(n_time_points, mean = g * 2, sd = 0.5)
  return(trend)
})

# Define varying dynamics for selected groups across other conditions
varying_groups <- sample(1:n_groups, x_varying_groups, replace = FALSE)

for (cond in 2:n_conditions) {
  group_dynamics[[cond]] <- group_dynamics[[1]]
  for (g in varying_groups) {
    group_dynamics[[cond]][[g]] <- rnorm(n_time_points, mean = g * 2, sd = 1)
  }
}

# Assign each feature to a group
feature_to_group <- sample(1:n_groups, n_features, replace = TRUE)

# Initialize a list to store the simulated data
simulated_data <- list()

# Assign metabolite names to features
available_metabolites <- metabolite_modules # Copy of metabolite database to keep track of unused names

# Simulate data for each feature across all conditions
for (feature in 1:n_features) {
  # Get the group for this feature
  group <- feature_to_group[feature]

  # Determine probability of each metabolite database group for this dynamic group
  group_probs <- group_probabilities[group, ]

  # Subset the metabolite database for selection based on group probabilities
  metabolite_candidates <- available_metabolites %>%
    group_by(middle_hierarchy) %>%
    mutate(Probability = group_probs[match(middle_hierarchy, unique(metabolite_modules$middle_hierarchy))]) %>%
    ungroup() %>%
    filter(metabolite %in% available_metabolites$metabolite) # Ensure the metabolite is still available

  # Randomly sample a metabolite based on these probabilities
  metabolite_name <- sample(metabolite_candidates$metabolite, 1, prob = metabolite_candidates$Probability)

  # Remove this metabolite from available pool
  available_metabolites <- available_metabolites[available_metabolites$metabolite != metabolite_name, ]

  # Generate a random base mean for this feature between 0.001 and 1000
  base_mean <- runif(1, min = 0.001, max = 1000)

  # Generate feature-specific variances for each time point
  feature_variances <- runif(n_time_points, min = 0.1, max = 2)

  # Store data for each condition
  for (cond in 1:n_conditions) {
    trend <- group_dynamics[[cond]][[group]]
    feature_means <- base_mean * trend / max(abs(trend))

    feature_data <- data.frame(
      metabolite = metabolite_name, # Assign metabolite name here
      condition = paste0(condition_names[[cond]]),
      time = rep(1:n_time_points, each = n_replicates),
      replicate = rep(1:n_replicates, times = n_time_points)
    )

    # Generate the actual data points with strictly positive concentrations
    feature_data$measurement <- unlist(lapply(1:n_time_points, function(t) {
      rlnorm(n_replicates, meanlog = log(feature_means[t]), sdlog = feature_variances[t])
    }))

    simulated_data[[length(simulated_data) + 1]] <- feature_data
  }
}

rm(base_mean,cond,feature,feature_means,feature_to_group,feature_variances,
   g,group,group_probs,metabolite_name,n_conditions,n_features,n_groups,n_replicates,
   n_time_points,trend,varying_groups,x_varying_groups,available_metabolites,feature_data,group_dynamics,
   group_probabilities,metabolite_candidates,condition_names,metabolite_modules)
# Combine all features and conditions into one data frame
simulated_data_df <- do.call(rbind, simulated_data)


simulated_data_df <- simulated_data_df %>%
  group_by(metabolite, condition) %>%
  mutate(
    log_m = log10(measurement),
    m_scaled = (log_m - mean(log_m)) / sd(log_m)
  )


data_sim <- simulated_data_df
rm(simulated_data_df,simulated_data)
use_data(data_sim,overwrite = TRUE)
#promptData(data_sim)
```


## intracellular concentrations
```{r}
intra <- read_csv("/media/home/5-1-package pipeline/data/intra_corrected_cell_counts.csv")
# save as rda file
use_data(intra)
# write documentation
promptData(intra)
```
## model fit for Vignette building
```{r}
# skip posteriors to reduce data size
diagnostics_dynamics <- diagnostics_dynamics["model_diagnostics"]
use_data(diagnostics_dynamics,overwrite = TRUE)
promptData(diagnostics_dynamics)
estimates_dynamics <- estimates_dynamics[c("0Gy","2Gy","10Gy")]
use_data(estimates_dynamics,overwrite=TRUE)
promptData(estimates_dynamics)
```



That is all we need for now.

# functions
## fit_dynamics_model
```{r}
use_r("fit_dynamics_model.R")
document()
load_all()
use_test("fit_dynamics_model.R")

# check if everything is available
MetaboDynamics::fit_dynamics_model() # is available
help("fit_dynamics_model") # should open help page
```

### extract_diagnostics_dynamics
```{r}
use_r("extract_diagnostics_dynamics.R")
document()
```

### extract_estimates_dynamics
```{r}
use_r("extract_estimates_dynamics.R")
document()
```

## OverRepresentationAnalysis with hypergeometric model
```{r}
use_r("ORA_hypergeometric.R")
document()
```

## compare_conditions
```{r}
use_r("compare_dynamics.R")
document()
use_r("compare_metabolites.R")
document()
```

# add citation
```{r}
usethis::use_citation() 
```
# add news
```{r}
usethis::use_news_md(open = rlang::is_interactive())
```


# Bioconductor tests
```{r}
#BiocManager::install("BiocCheck")
BiocCheck::BiocCheck()
```

# add BiocViews terms
add BiocView terms to Description file biocViews:term1,term2,term3

# test examples
```{r}
devtools::run_examples() 
```
# Vignette
install package BiocStyle
```{r}
BiocManager::install("BiocStyle")
```

