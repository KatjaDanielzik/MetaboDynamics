---
title: "MetaboDynamics"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{MetaboDynamics}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```
Here we want to show a complete workflow to analyze concentration tables.
As example we have a data set of irradiated cancer cells lines that were observed
over four timepoints.
This package was built to faciliate the analysis of longitudinal metabolomics
data. Common tools mostly only allow the comparison between two timepoints or
experimental conditions and are using frequentist statistical methods. As 
metabolomics data is often noise robust methods for the estimation of dynamics
are needed. We employ a hierachical Bayesian model for that. 

## setup: load required packages
```{r setup}
library(MetaboDynamics)
library(ggplot2)
library(dplyr)
library(tidyr)
```

## load data and plot data overview
```{r,fig.align='center',fig.dpi=150}
data("intra")
ggplot(intra, aes(x = cpc)) +
  geom_density() +
  theme_bw() +
  facet_grid(cols = vars(time), rows = vars(dose)) +
  ggtitle("raw data", "cpc values")
```

We can see that there are only measurements at 0h for the 0Gy dose. As this
is the control before irradiation the 0h measurement also is valid for the 2Gy 
and 10Gy group. Furthermore we can see that the cpc values are not distributed
normally.
So let's assign the 0h values also to 2Gy and 10 Gy and log-transform.
```{r,fig.align='center',fig.dpi=150}
# we are taking t=0h for every radiation dose
# we will duplicate the measurements for 0h for 2Gy and 10Gy
temp <- intra[intra$time == "0h", ]
temp$dose <- "2Gy"
temp2 <- temp
temp2$dose <- "10Gy"
intra <- rbind(intra, temp, temp2)
rm(temp, temp2)
intra <- intra %>% mutate(log_cpc = log10(cpc))

# we standardize to a mean of zero and a standard deviation of one of log-transformed data
ggplot(intra, aes(x = log_cpc)) +
  geom_density() +
  theme_bw() +
  facet_grid(cols = vars(time), rows = vars(dose)) +
  ggtitle("data", "log(cpc) values")
```

That looks better. As we want to estimate the dynamics of every single 
metabolite next let's think about what that means. We want to estimate the 
deviations at every single time point from the metabolites mean over time. 
```{r,fig.align='center',fig.dpi=150}
# get time as numeric variable
intra$time <- gsub("h", "", intra$time)
intra$time <- as.numeric(intra$time)
intra <- intra %>% arrange(as.numeric(time))
ggplot(intra) +
  geom_line(aes(x = as.numeric(as.factor(time)), y = log_cpc, col = metabolite)) +
  theme_bw() +
  xlab("timepoint") +
  theme(legend.position = "none") +
  facet_grid(rows = vars(dose)) +
  ggtitle("raw metabolite dynamics", "col=metabolite")
```

As the concentrations of metabolites can differ by magnitudes from each other, 
we standardize each metabolite at each radiation dose to a mean of zero and a 
standard deviation of one. 
```{r,fig.align='center',fig.dpi=150}
intra <- intra %>%
  group_by(dose, metabolite) %>%
  mutate(log_cpc_stand = ((log_cpc - mean(log_cpc)) / sd(log_cpc)))
ggplot(intra) +
  geom_line(aes(
    x = as.numeric(as.factor(time)),
    y = log_cpc_stand, col = metabolite
  )) +
  theme_bw() +
  xlab("timepoint") +
  theme(legend.position = "none") +
  facet_grid(rows = vars(dose)) +
  ggtitle("standardized dynamics", "col=metabolite")
```

Now we can finally model the dynamics.
We have done the modeling beforehand, so that it does not take to much time
during this Vignette. 

## Model dynamics
```{r,fig.align='center',fig.dpi=150}
# fit model
fits_dynamics <- fit_dynamics_model(
  data = intra, cpc = "log_cpc_stand",
  condition = "dose", max_treedepth = 14,
  adapt_delta = 0.999, iter = 4000, cores = 7
)


# load("/media/home/fits_dynamics.RData")
# extract diagnostics
diagnostics_dynamics <- extract_diagnostics_dynamics(
  data = intra, iter = 4000,
  fits = fits_dynamics
)
diagnostics_dynamics[["plot_divergences"]]
diagnostics_dynamics[["plot_treedepth_error"]]
diagnostics_dynamics[["plot_rhat"]]
diagnostics_dynamics[["plot_neff"]]
diagnostics_dynamics[["plot_PCC_0Gy"]]
diagnostics_dynamics[["plot_PCC_2Gy"]]
diagnostics_dynamics[["plot_PCC_10Gy"]]
```


For our experimental dataset this might take up to 10 minutes per radiation dose
depending on how many cores are used. 

This returns a list of model fits that are named by the experimental condition
("0Gy","2Gy","10Gy"). With extract_diagnostics_dynamics() we can extract all
the diagnostic criteria of Bayesian models (rhat,neff,divergences,max_treedept)
and visualize them. Additionally dataframes for visual Posterior predictive 
checks (PPC) are prepared and Plots generated for the PPCs and diagnostic 
criteria.

After checking the diagnostic criteria and the PPC we can extract the estimates:

```{r,fig.align='center',fig.dpi=150}
# extract estimates
estimates_dynamics <- extract_estimates_dynamics(
  data = intra, fits = fits_dynamics,
  iter = 4000
)
```

We get two major outputs:
1) the estimation of concentration differences between two subsequent timepoints
  of each metabolite at each experimental condition
2) the dynamic profiles of each metabolites at each experimental condition

## 1) differences between two timepoints
```{r,fig.align='center',out.width="100%"}
# 1) the differences between two timepoints
# set numer of timepoints
estimates_dynamics[["plot_timepoint_differences"]]
```


If the 95% highest density interval of the posterior does not include zero
we can confidently stat that there is a difference in mean concentrations 
between two timepoints. If the 95% HDI is left of zero we have a decrease in
concentrations between the two timepoints, if it is right of zero we have an
increase in concentrations between timepoints. 

## 2) dynamic profiles
```{r,fig.align='center',out.width="100%"}
# 2) dynamic profiles
estimates_dynamics[["plot_dynamics"]]
```

So we now have dynamic profiles of the metabolites at each radiation dose.
What do we do with this?
We could cluster these dynamics vectors, that we obtained (estimates_dynamics[,c("mu1.mean":"mut.mean)]) to see if we find groups of metabolites that
have similar dynamics.


# cluster dynamics
For the sake of demonstration we only show a rudimentary hierachical clustering
with the number of optimal clusters determined beforehand with clustering 
criteria in the package "factoextra".
```{r,echo=FALSE}
# get distances between vectors
dd_0Gy <- dist(
  estimates_dynamics[["0Gy"]][, c(
    "mu1_mean", "mu2_mean",
    "mu3_mean", "mu4_mean"
  )],
  method = "euclidean"
)
# hierachical clustering
clust <- hclust(dd_0Gy, method = "ward.D2")
clust_cut <- cutree(clust, k = 7)
# assing cluster ID to estimates
clust_0Gy <- estimates_dynamics[["0Gy"]][, c(
  "metabolite", "condition", "mu1_mean", "mu2_mean",
  "mu3_mean", "mu4_mean"
)]
clust_0Gy$cluster <- clust_cut

rm(dd_0Gy, clust, clust_cut)

# get distances between vectors
dd_2Gy <- dist(
  estimates_dynamics[["2Gy"]][, c(
    "mu1_mean", "mu2_mean",
    "mu3_mean", "mu4_mean"
  )],
  method = "euclidean"
)
# hierachical clustering
clust <- hclust(dd_2Gy, method = "ward.D2")
clust_cut <- cutree(clust, k = 8)
# assing cluster ID to estimates
clust_2Gy <- estimates_dynamics[["2Gy"]][, c(
  "metabolite", "condition", "mu1_mean", "mu2_mean",
  "mu3_mean", "mu4_mean"
)]
clust_2Gy$cluster <- clust_cut

rm(dd_2Gy, clust, clust_cut)

# get distances between vectors
dd_10Gy <- dist(
  estimates_dynamics[["10Gy"]][, c(
    "mu1_mean", "mu2_mean",
    "mu3_mean", "mu4_mean"
  )],
  method = "euclidean"
)
# hierachical clustering
clust <- hclust(dd_10Gy, method = "ward.D2")
clust_cut <- cutree(clust, k = 8)
# assing cluster ID to estimates
clust_10Gy <- estimates_dynamics[["10Gy"]][, c(
  "metabolite", "condition", "mu1_mean", "mu2_mean",
  "mu3_mean", "mu4_mean"
)]
clust_10Gy$cluster <- clust_cut
rm(dd_10Gy, clust, clust_cut)

cluster <- rbind(clust_0Gy, clust_2Gy, clust_10Gy)
rm(clust_0Gy, clust_2Gy, clust_10Gy)
```

We combine all clustering results in one dataframe that hold columns "metabolite",
"condition", "mu1-t.mean" and "cluster". "Cluster" refers to the cluster ID
of the metabolite.

```{r,fig.align='center',fig.dpi=150}
temp <- cluster
temp <- temp %>% pivot_longer(
  cols = c(mu1_mean, mu2_mean, mu3_mean, mu4_mean),
  names_to = "timepoint", values_to = "mu_mean"
)
ggplot(temp, aes(
  x = as.factor(as.numeric(as.factor(timepoint))),
  y = mu_mean, group = metabolite
)) +
  geom_line() +
  xlab("timepoint") +
  ylab("estimated mean concentration") +
  theme_bw() +
  theme(legend.position = "none") +
  facet_grid(rows = vars(condition), cols = vars(cluster)) +
  ggtitle("clustered dynamics", "color=metabolite, panels=cluster ID")
```


# Over-representation analysis of functional modules in dynamic clusters
We now have clusters of metabolites with similar dynamics per radiation dose.
To quantify the possible biological function of these dynamic clusters we 
retrieved from the KEGG-database the following information 
(with package KEGGREST):
1) to which functional modules our experimental metabolites are annotated and
2) which metabolites are annotated to functional modules in general
The functional modules of the KEGG-database are organised in three hierchacies:
upper, middle and lower. Here we will do funtional analysis on the middle 
hierachy. 
To facilitate analysis the dataframes "metabolite_modules" which holds the 
information about experimental metabolites and "modules_compounds" which holds
the information about which metabolites are in general annotated to functional 
modules. 
We load both datasets and can inspect the documentation.
```{r}
data("metabolite_modules")
help("metabolite_modules")
head(metabolite_modules)
data("modules_compounds")
help("modules_compounds")
head(modules_compounds)
```

For the functional analysis we employ a hypergeometric model:
```{r,fig.align='center',out.width="100%"}
ORA <- ORA_hypergeometric(background = modules_compounds, annotations = metabolite_modules, clusters = cluster, tested_column = "middle_hierachy")
ORA[["plot_ORA"]]
ORA <- ORA_hypergeometric(background = modules_compounds, annotations = metabolite_modules, clusters = cluster[cluster$condition == "0Gy", ], tested_column = "lower_hierachy")
ORA[["plot_ORA"]]
```

Great, we can now see which functional module is over- or under-represented in which
dynamic cluster!

# Comparison of dynamics between clusters of different experimental conditions
We can not only do over-representation analysis of KEGG-functional modules but
also compare dynamic clusters across different experimental conditions.
```{r}
comparison <- compare_conditions(clusters = cluster, dynamics = c("mu1_mean", "mu2_mean", "mu3_mean", "mu4_mean"))
comparison[["plot_comparison"]]
```
The bigger and brighter a point is the smaller is the mean distance between
dynamic clusters and the smaller is the standard deviation. That means big bright
moins indicate high dynamic similarity which small spread. Here 10Gy_7 and 2Gy_8
have high similiarty in dynamics. If we recall the ORA analysis this pair also
has similar patterns in ORA of functional modules. 10Gy_1 and 0Gy_1 however

