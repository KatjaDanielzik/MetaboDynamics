---
title: "MetaboDynamics: a worked example"
package: MetaboDynamics
author: "Katja Danielzik"

output:
  BiocStyle::html_document:
    toc: true
    toc_depth: 2
vignette: >
  %\VignetteIndexEntry{1. MetaboDynamics}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r style, echo = FALSE, results = 'asis'}
  BiocStyle::markdown()
```

Here we want to show a complete workflow to analyze concentration tables.
As example we have a data set of irradiated cancer cells lines that were observed
over four timepoints.
This package was built to faciliate the analysis of longitudinal metabolomics
data. Common tools mostly only allow the comparison between two timepoints or
experimental conditions and are using frequentist statistical methods. As 
metabolomics data is often noise robust methods for the estimation of dynamics
are needed. We employ a hierachical Bayesian model for that. 

## setup: load required packages
```{r setup}
library(MetaboDynamics)
library(ggplot2)
library(dplyr)
library(tidyr)
```

## load data and plot data overview
```{r,fig.wide=TRUE}
data("data_sim")
ggplot(data_sim, aes(x = measurement)) +
  geom_density() +
  theme_bw() +
  facet_grid(cols = vars(time), rows = vars(condition)) +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))+
  ggtitle("raw data", "raw measurements")
```
We have a simulated data set of 98 metabolites with three measurement replicates
at four time points (1-4) across 3 experimental conditions (A-B).
The raw data is not distributed normally. So let's log-transform the values.
In the integrated simulated dataset this is already done in the column "log_m".
```{r,fig.wide=TRUE}
# we standardize to a mean of zero and a standard deviation of one of log-transformed data
ggplot(data_sim, aes(x = log_m)) +
  geom_density() +
  theme_bw() +
  facet_grid(cols = vars(time), rows = vars(condition)) +
  ggtitle("data", "log-transformed values")
```

That looks better. As we want to estimate the dynamics of every single 
metabolite next let's think about what that means. We want to estimate the 
deviations at every single time point from the metabolites mean over time. 

```{r,fig.wide=TRUE}
ggplot(data_sim) +
  geom_line(aes(x = time, y = log_m, col = metabolite)) +
  theme_bw() +
  xlab("timepoint") +
  theme(legend.position = "none") +
  facet_grid(rows = vars(condition)) +
  ggtitle("raw metabolite dynamics", "color=metabolite")
```

As the concentrations of metabolites can differ by magnitudes from each other, 
we standardize each metabolite at each radiation dose to a mean of zero and a 
standard deviation of one. In the simulated data set the scaled measurements
are in column "m_scaled".
```{r,fig.wide=TRUE}
ggplot(data_sim) +
  geom_line(aes(
    x = time,
    y = m_scaled, col = metabolite
  )) +
  theme_bw() +
  xlab("timepoint") +
  theme(legend.position = "none") +
  facet_grid(rows = vars(condition)) +
  ggtitle("standardized dynamics", "color=metabolite")
```

Now we can finally model the dynamics.
This might take up to 10 minutes. 

## Model dynamics
```{r,fig.wide=TRUE}
# fit model
fits_dynamics <- fit_dynamics_model(
  data = data_sim, scaled_measurement = "m_scaled", time="time",
  condition = "condition", max_treedepth = 14,
  adapt_delta = 0.999, iter = 4000, cores = 7, chains=1)

# extract diagnostics
diagnostics_dynamics <- extract_diagnostics_dynamics(
  data = data_sim, iter = 4000, # make sure iter is the same as used for fitting
                                # the dynamic model
  scaled_measurement="m_scaled",       
  fits = fits_dynamics
)

diagnostics_dynamics[["plot_divergences"]]
diagnostics_dynamics[["plot_treedepth_error"]]
diagnostics_dynamics[["plot_rhat"]]
diagnostics_dynamics[["plot_neff"]]

# PPCs can be accessed with
diagnostics_dynamics[["plot_PPC_A"]]
diagnostics_dynamics[["plot_PPC_B"]]
diagnostics_dynamics[["plot_PPC_C"]]
```

For our simulated dataset with varying variances at each timepoint this might take up to 10 minutes per radiation dose
depending on how many cores are used. 

This returns a list of model fits that are named by the experimental condition
("0Gy","2Gy","10Gy"). With extract_diagnostics_dynamics() we can extract all
the diagnostic criteria of Bayesian models (rhat,neff,divergences,max_treedept)
and visualize them. Additionally dataframes for visual Posterior predictive 
checks (PPC) are prepared and Plots generated for the PPCs and diagnostic 
criteria.

After checking the diagnostic criteria and the PPC we can extract the estimates:

```{r,fig.wide=TRUE}
# #extract estimates
estimates_dynamics <- extract_estimates_dynamics(condition="condition",
  data = data_sim, fits = fits_dynamics,samples=1,
  iter = 4000
)
```

We get two major outputs:
1) the estimation of concentration differences between two subsequent timepoints
  of each metabolite at each experimental condition
2) the dynamic profiles of each metabolites at each experimental condition

## 1) differences between two timepoints
```{r,fig.wide=TRUE}
#1) the differences between two timepoints
estimates_dynamics[["plot_timepoint_differences"]]
```
If the 95% highest density interval of the posterior does not include zero
we can confidently stat that there is a difference in mean concentrations 
between two timepoints. If the 95% HDI is left of zero we have a decrease in
concentrations between the two timepoints, if it is right of zero we have an
increase in concentrations between timepoints. 

## 2) dynamic profiles
```{r,fig.wide=TRUE}
# 2) dynamic profiles
estimates_dynamics[["plot_dynamics"]]
```
So we now have dynamic profiles of the metabolites at each radiation dose.
What do we do with this?
We could cluster these dynamics vectors, that we obtained (estimates_dynamics[,c("mu1.mean":"mut.mean)]) to see if we find groups of metabolites that
have similar dynamics.


# cluster dynamics
For the sake of demonstration we only show a rudimentary hierachical clustering
with the number of optimal clusters determined beforehand with clustering 
criteria in the package "factoextra".
```{r,echo=FALSE}
# # get distances between vectors
# dd_0Gy <- dist(
#   estimates_dynamics[["0Gy"]][, c(
#     "mu1_mean", "mu2_mean",
#     "mu3_mean", "mu4_mean"
#   )],
#   method = "euclidean"
# )
# # hierachical clustering
# clust <- hclust(dd_0Gy, method = "ward.D2")
# clust_cut <- cutree(clust, k = 7)
# # assing cluster ID to estimates
# clust_0Gy <- estimates_dynamics[["0Gy"]][, c(
#   "metabolite", "condition", "mu1_mean", "mu2_mean",
#   "mu3_mean", "mu4_mean"
# )]
# clust_0Gy$cluster <- clust_cut
# 
# rm(dd_0Gy, clust, clust_cut)
# 
# # get distances between vectors
# dd_2Gy <- dist(
#   estimates_dynamics[["2Gy"]][, c(
#     "mu1_mean", "mu2_mean",
#     "mu3_mean", "mu4_mean"
#   )],
#   method = "euclidean"
# )
# # hierachical clustering
# clust <- hclust(dd_2Gy, method = "ward.D2")
# clust_cut <- cutree(clust, k = 8)
# # assing cluster ID to estimates
# clust_2Gy <- estimates_dynamics[["2Gy"]][, c(
#   "metabolite", "condition", "mu1_mean", "mu2_mean",
#   "mu3_mean", "mu4_mean"
# )]
# clust_2Gy$cluster <- clust_cut
# 
# rm(dd_2Gy, clust, clust_cut)
# 
# # get distances between vectors
# dd_10Gy <- dist(
#   estimates_dynamics[["10Gy"]][, c(
#     "mu1_mean", "mu2_mean",
#     "mu3_mean", "mu4_mean"
#   )],
#   method = "euclidean"
# )
# # hierachical clustering
# clust <- hclust(dd_10Gy, method = "ward.D2")
# clust_cut <- cutree(clust, k = 8)
# # assing cluster ID to estimates
# clust_10Gy <- estimates_dynamics[["10Gy"]][, c(
#   "metabolite", "condition", "mu1_mean", "mu2_mean",
#   "mu3_mean", "mu4_mean"
# )]
# clust_10Gy$cluster <- clust_cut
# rm(dd_10Gy, clust, clust_cut)
# 
# cluster <- rbind(clust_0Gy, clust_2Gy, clust_10Gy)
# rm(clust_0Gy, clust_2Gy, clust_10Gy)
```

We combine all clustering results in one dataframe that hold columns "metabolite",
"condition", "mu1-t.mean" and "cluster". "Cluster" refers to the cluster ID
of the metabolite.

```{r,fig.wide=TRUE}
# temp <- cluster
# temp <- temp %>% pivot_longer(
#   cols = c(mu1_mean, mu2_mean, mu3_mean, mu4_mean),
#   names_to = "timepoint", values_to = "mu_mean"
# )
# ggplot(temp, aes(
#   x = as.factor(as.numeric(as.factor(timepoint))),
#   y = mu_mean, group = metabolite
# )) +
#   geom_line() +
#   xlab("timepoint") +
#   ylab("estimated mean concentration") +
#   theme_bw() +
#   theme(legend.position = "none") +
#   facet_grid(rows = vars(condition), cols = vars(cluster)) +
#   ggtitle("clustered dynamics", "panels=cluster ID")
# 
# png(file = "dynamics.png", pointsize = 60, width = 20, height = 10, res = 1000, units = "cm")
# ggplot(data = temp[temp$condition == "2Gy" & temp$metabolite == "L-Arginine", ], aes(x = as.numeric(as.factor(timepoint)), y = mu_mean, group = metabolite, col = "red")) +
#   geom_line(data = temp[temp$condition == "2Gy", ], aes(
#     x = as.factor(as.numeric(as.factor(timepoint))),
#     y = mu_mean, group = metabolite, col = "black"
#   )) +
#   geom_line(lwd = 1) +
#   xlab("timepoint") +
#   ylab("deviation from mean concentration") +
#   theme_bw() +
#   scale_color_manual(values = c("black" = "black", "red" = "red")) +
#   theme(legend.position = "none") +
#   facet_grid(rows = vars(condition), cols = vars(cluster)) +
#   ggtitle("clustered dynamics", "red=L-Arginine, panels=cluster ID")
# dev.off()
# 
# rm(temp)
```


# Over-representation analysis of functional modules in dynamic clusters
We now have clusters of metabolites with similar dynamics per radiation dose.
To quantify the possible biological function of these dynamic clusters we 
retrieved from the KEGG-database the following information 
(with package KEGGREST):
1) to which functional modules our experimental metabolites are annotated and
2) which metabolites are annotated to functional modules in general
The functional modules of the KEGG-database are organised in three hierchacies:
upper, middle and lower. Here we will do funtional analysis on the middle 
hierachy. 
To facilitate analysis the dataframes "metabolite_modules" which holds the 
information about experimental metabolites and "modules_compounds" which holds
the information about which metabolites are in general annotated to functional 
modules. 
We load both datasets and can inspect the documentation.
```{r}
data("metabolite_modules")
help("metabolite_modules")
head(metabolite_modules)
data("modules_compounds")
help("modules_compounds")
head(modules_compounds)
```

For the functional analysis we employ a hypergeometric model:
```{r,fig.wide=TRUE}
# ORA <- ORA_hypergeometric(background = modules_compounds, annotations = metabolite_modules, clusters = cluster, tested_column = "middle_hierachy")
# ORA[["plot_ORA"]]
# 
# a_clusters <- ORA[["ORA"]]
# 
# png(file = "ORA.png", pointsize = 60, width = 20, height = 8, res = 1000, units = "cm")
# a_clusters <- a_clusters %>% mutate(col = ifelse(log(OvE_gen_higher) < 0, "ICR<0", ifelse(log(OvE_gen_lower) > 0, "ICR>0", "ICR includes 0")))
# ggplot(a_clusters[a_clusters$condition == "2Gy", ], aes(x = log(OvE_gen), y = module_name, col = col)) +
#   geom_errorbarh(aes(xmin = log(OvE_gen_lower), xmax = log(OvE_gen_higher))) +
#   geom_point(aes(x = log(OvE_gen_median))) +
#   geom_vline(xintercept = 0, linetype = "dashed") +
#   theme_bw() +
#   scale_color_manual(values = c("ICR includes 0" = "black", "ICR>0" = "green")) +
#   xlab("log(p(OvE))") +
#   guides(col = "none") +
#   facet_grid(cols = vars(cluster), rows = vars(condition)) +
#   ggtitle("hypergeometric ORA", "median and 95% interquantile range,
#               panels=clusterID")
# dev.off()
# 
# ORA_lower <- ORA_hypergeometric(background = modules_compounds, annotations = metabolite_modules, clusters = cluster[cluster$condition == "0Gy", ], tested_column = "lower_hierachy")
# ORA_lower[["plot_ORA"]]
```

Great, we can now see which functional module is over- or under-represented in which
dynamic cluster!

# Comparison of clusters of different experimental conditions

## dynamics 
We can not only do over-representation analysis of KEGG-functional modules but
also compare dynamic clusters across different experimental conditions.
```{r,fig.aling='center',fig.dpi=150}
# comparison_dynamics <- compare_dynamics(clusters = cluster, dynamics = c("mu1_mean", "mu2_mean", "mu3_mean", "mu4_mean"))
# 
# comparison_dynamics[["plot_dynamic_comparison"]]
```
The bigger and brighter a point is the smaller is the mean distance between
dynamic clusters and the smaller is the standard deviation. That means big bright
moins indicate high dynamic similarity which small spread. Here 10Gy_7 and 2Gy_8
have high similiarity in dynamics. If we recall the ORA analysis this pair also
2Gy_8 has less over-expression of Carbohydrate metabolism. 

## metabolites
```{r,fig.aling='center',fig.dpi=150}
# comparison_metabolites <- compare_metabolites(clusters = cluster)
# comparison_metabolites[["plot_metabolite_comparison"]]
```
We have two clusters that are very similar in their metabolite composition:
10Gy_5 and 2Gy_6. If we compare that to the dynamic profiles and ORA analysis
we see that similar functional modules are over-expressed as expected BUT
the dynamics differ between the two radiation doses. 

Can we facilitate visualization?

## combine both
```{r,fig.aling='center',fig.dpi=150}
# dynamics <- comparison_dynamics[["estimates"]]
# metabolites <- comparison_metabolites[["Jaccard"]]
# temp <- left_join(dynamics, metabolites, by = c("cluster_a", "cluster_b"))
# ggplot(temp, aes(x = 1 / mu_mean, y = Jaccard)) +
#   geom_point(aes(col = 1 / sigma_mean)) +
#   theme_bw() +
#   geom_text(aes(label = ifelse(Jaccard > 0.4 & 1 / mu_mean < 1.0, comparison, NA)), nudge_y = -0.03) +
#   scale_color_viridis_c() +
#   xlab("dynamics similarity") +
#   ylab("metabolite similarity") +
#   ggtitle("comparison of clusters")
# 
# 
# 
# x <- unique(temp[, "cluster_a"])
# temp <- temp %>% mutate(scale_Jaccard = scale(Jaccard))
# png(file = "comparison.png", pointsize = 60, width = 12, height = 12, res = 1000, units = "cm")
# ggplot(temp, aes(x = cluster_b, y = cluster_a)) +
#   geom_point(aes(size = Jaccard, col = mu_mean)) +
#   theme_bw() +
#   scale_color_viridis_c(option = "magma") +
#   scale_x_discrete(limits = x) +
#   xlab("") +
#   ylab("") +
#   scale_y_discrete(limits = x) +
#   guides(col = "none", size = "none") +
#   theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1)) +
#   labs(col = "dynamic distance", size = "metabolite similarity") +
#   ggtitle("comparison of clusters")
# dev.off()
```
We can find two cluster pairs that are pretty similar in regards to their
composing metabolites but dissimilar in regards to their dynamics. Their ORA
profiles are quit similar as expected from the similar metabolite compositions. 
```{r}
sessionInfo()
```

